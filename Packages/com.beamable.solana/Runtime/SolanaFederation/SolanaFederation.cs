using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Beamable.Common;
using Beamable.Common.Api;
using Beamable.Common.Api.Inventory;
using Beamable.Microservices.SolanaFederation.Features.Authentication;
using Beamable.Microservices.SolanaFederation.Features.Authentication.Exceptions;
using Beamable.Microservices.SolanaFederation.Features.Collections;
using Beamable.Microservices.SolanaFederation.Features.Minting;
using Beamable.Microservices.SolanaFederation.Features.Transaction;
using Beamable.Microservices.SolanaFederation.Features.Wallets;
using Beamable.Server;
using Beamable.Server.Api.RealmConfig;

namespace Beamable.Microservices.SolanaFederation
{
    [Microservice("SolanaFederation",
        CustomAutoGeneratedClientPath =
            "Packages/com.beamable.solana/Runtime/Client/Autogenerated/SolanaFederationClient")]
    public class SolanaFederation : Microservice, IFederatedInventory<SolanaCloudIdentity>
    {
        [InitializeServices]
        public static async Task Initialize(IServiceInitializer initializer)
        {
            ServiceContext.Requester = initializer.GetService<IBeamableRequester>();

            // Load realm-scoped configuration
            var realmConfigService = initializer.GetService<IMicroserviceRealmConfigService>();
            Configuration.RealmConfig = await realmConfigService.GetRealmConfigSettings();

            var storage = initializer.GetService<IStorageObjectConnectionProvider>();
            var db = await storage.SolanaStorageDatabase();
            ServiceContext.Database = db;

            TransactionManager.InitTransactionState();

            // Fetch the realm wallet on service start for early initialization
            var realmWallet = await WalletService.GetOrCreateRealmWallet();
            ServiceContext.RealmWallet = realmWallet;
            TransactionManager.AddSigner(realmWallet.Account);

            // Fetch the default token collection on service start for early initialization
            var _ = await CollectionService.GetOrCreateCollection(Configuration.DefaultTokenCollectionName);

            if (TransactionManager.HasInstructions()) await TransactionManager.Execute();
        }

        public Promise<FederatedAuthenticationResponse> Authenticate(string token, string challenge, string solution)
        {
            if (string.IsNullOrEmpty(token))
            {
                BeamableLogger.LogError("We didn't receive a token (public key)");
                throw new InvalidAuthenticationRequest("Token (public key) is required");
            }

            if (!string.IsNullOrEmpty(challenge) && !string.IsNullOrEmpty(solution))
            {
                // Verify the solution
                if (AuthenticationService.IsSignatureValid(token, challenge, solution))
                    // User identity is confirmed
                    return Promise<FederatedAuthenticationResponse>.Successful(new FederatedAuthenticationResponse
                        { user_id = token });
                // Signature is invalid, user identity isn't confirmed
                BeamableLogger.LogWarning(
                    "Invalid signature {signature} for challenge {challenge} and wallet {wallet}", solution,
                    challenge, token);
                throw new UnauthorizedException();
            }

            // Generate a challenge
            return Promise<FederatedAuthenticationResponse>.Successful(new FederatedAuthenticationResponse
            {
                challenge = $"Please sign this random message to authenticate, {Guid.NewGuid()}",
                challenge_ttl = Configuration.AuthenticationChallengeTtlSec
            });
        }

        public async Promise<FederatedInventoryProxyState> StartInventoryTransaction(string id, string transaction,
            Dictionary<string, long> currencies, List<ItemCreateRequest> newItems)
        {
            BeamableLogger.Log("Processing start transaction request {TransactionId}", transaction);

            TransactionManager.InitTransactionState();
            await TransactionManager.SaveInventoryTransaction(transaction);

            try
            {
                // All mints are initiated using the realm wallet so it needs to sign every transaction
                TransactionManager.AddSigner(ServiceContext.RealmWallet.Account);

                var mints = new Mints();

                // Load persisted content/mint mappings
                await mints.LoadPersisted();

                // Compute the current player token state
                var playerTokenState = await PlayerTokenState.Compute(id, mints);

                // Mint new items as NFTs
                var newItemTokens = await mints.MintNewItems(newItems, id);
                playerTokenState.MergeIn(newItemTokens);

                // TODO: update support for NFT metadata

                // Mint new currency as FTs 
                var newCurrencyTokens = await mints.MintNewCurrency(id, currencies, playerTokenState);
                playerTokenState.MergeIn(newCurrencyTokens);

                // Execute the transaction
                await TransactionManager.Execute();

                // Return the new federated state
                return playerTokenState.ToProxyState();
            }
            catch (Exception ex)
            {
                BeamableLogger.LogError("Error processing transaction {transaction} -> {error}. Clearing the transaction record to enable retries.", transaction, ex.Message);
                await TransactionManager.ClearInventoryTransaction(transaction);
                throw;
            }
        }

        public async Promise<FederatedInventoryProxyState> GetInventoryState(string id)
        {
            var mints = new Mints();

            // Load persisted content/mint mappings
            await mints.LoadPersisted();

            // Compute the current player token state
            var playerTokenState = await PlayerTokenState.Compute(id, mints);

            // Return the federated state
            return playerTokenState.ToProxyState();
        }
    }
}